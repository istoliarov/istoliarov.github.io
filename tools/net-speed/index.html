<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Net Speed Test</title>
  <style>
    :root{
      --bg:#0f1724;
      --card:#0b1220;
      --accent:#06b6d4;
      --muted:#94a3b8;
      color-scheme: dark;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071023 0%, #071a2b 100%);color:#e6eef6}
    .wrap{max-width:840px;margin:40px auto;padding:24px}
    .card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:20px;border-radius:12px}
    h1{margin:0 0 12px;font-size:20px}
    .controls{display:flex;gap:12px;align-items:center;margin:16px 0}
    button{background:var(--accent);border:none;padding:10px 16px;border-radius:8px;color:#042027;cursor:pointer;font-weight:600}
  button:disabled{opacity:0.5;cursor:not-allowed}
  select:disabled, input:disabled{opacity:0.6;cursor:not-allowed}
    select{padding:8px;border-radius:8px;border:none;background:#08202a;color:#dff6fb}
    .progress{height:18px;background:rgba(255,255,255,0.03);border-radius:10px;overflow:hidden}
    .progress > i{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent),#3b82f6);transition:width 250ms linear}
    .status{margin-top:12px;color:var(--muted);font-size:14px}
    .results{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:16px}
    .result{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:8px;text-align:center}
    .big{font-size:22px;font-weight:700}
    .small{font-size:12px;color:var(--muted)}
    .footer{margin-top:18px;font-size:13px;color:var(--muted)}
    @media(max-width:700px){.results{grid-template-columns:1fr}} 
  </style>
</head>
<body>
  <div class="wrap card">
    <h1>Internet Speed Test</h1>
    <div class="controls">
      <button id="runBtn">Run test</button>
      <!-- Host selector removed; using reliable public endpoints (httpbin.org, speed.hetzner.de) -->
      <label for="unit" style="color:var(--muted);font-size:13px">Units</label>
      <select id="unit">
        <option value="kbps">kbps</option>
        <option value="mbps" selected>Mbps</option>
        <option value="gbps">Gbps</option>
      </select>
      <div style="flex:1"></div>
      <div class="small" style="color:var(--muted)">This test runs entirely in your browser using public endpoints.</div>
    </div>

    <div class="progress" aria-hidden>
      <i id="progressBar"></i>
    </div>
    <div class="status" id="status">Idle</div>

    <div class="results" id="results" style="display:none">
      <div class="result">
        <div class="small">Download</div>
        <div id="dl" class="big">—</div>
        <div id="dl-unit" class="small">Mbps</div>
      </div>
      <div class="result">
        <div class="small">Upload</div>
        <div id="ul" class="big">—</div>
        <div id="ul-unit" class="small">Mbps</div>
      </div>
      <div class="result">
        <div class="small">Ping</div>
        <div id="ping" class="big">—</div>
        <div id="ping-unit" class="small">ms</div>
      </div>
    </div>

    <div class="footer">Note: Browser-only speed tests are approximate. For more accurate results use a dedicated native app.</div>
  </div>

<script>
(function(){
  const runBtn = document.getElementById('runBtn');
  const progressBar = document.getElementById('progressBar');
  const status = document.getElementById('status');
  const resultsEl = document.getElementById('results');
  const dlEl = document.getElementById('dl');
  const ulEl = document.getElementById('ul');
  const pingEl = document.getElementById('ping');
  const unitSel = document.getElementById('unit');
  const dlUnit = document.getElementById('dl-unit');
  const ulUnit = document.getElementById('ul-unit');

  // Small helper to format speed into unit
  function formatSpeed(bps, unit){
    // bps = bits per second
    if (!isFinite(bps)) return '—';
    switch(unit){
      case 'kbps': return (bps/1e3).toFixed(2);
      case 'mbps': return (bps/1e6).toFixed(2);
      case 'gbps': return (bps/1e9).toFixed(3);
      default: return (bps/1e6).toFixed(2);
    }
  }

  function setUnitsLabels(){
    const u = unitSel.value;
    dlUnit.textContent = u === 'kbps' ? 'kbps' : u === 'mbps' ? 'Mbps' : 'Gbps';
    ulUnit.textContent = dlUnit.textContent;
  }
  unitSel.addEventListener('change', setUnitsLabels);
  setUnitsLabels();

  // endpoints: use CORS-friendly public endpoints
  const DOWNLOAD_URLS = [
    'https://speed.hetzner.de/100MB.bin',
    'https://speed.hetzner.de/10MB.bin'
  ];
  const DOWNLOAD_URL = DOWNLOAD_URLS[1]; // 10MB
  const PING_API = 'https://httpbin.org/get';
  const PING_IMAGE = 'https://httpbin.org/image/png';
  const UPLOAD_URL = 'https://httpbin.org/post';

  // Progress helper
  function setProgress(p){ progressBar.style.width = Math.min(100,Math.max(0,p)) + '%'; }

  async function measurePing(){
    const tries = 4;
    let sum = 0;
    status.textContent = 'Measuring ping...';
    for(let i=0;i<tries;i++){
      const t0 = performance.now();
      try{
        // try a light HTTP GET to httpbin (CORS-friendly) to measure latency
        await fetch(PING_API + '?_=' + Math.random(), {cache:'no-store', mode:'cors'});
        const t1 = performance.now();
        sum += (t1 - t0);
        setProgress((i+1)/(3+tries) * 100);
      }catch(e){
        // fallback to image endpoint for timing
        try{
          const dur = await new Promise((resolve)=>{
            const img = new Image();
            let done = false;
            const tStart = performance.now();
            img.onload = ()=>{ if(!done){ done=true; resolve(performance.now() - tStart); } };
            img.onerror = ()=>{ if(!done){ done=true; resolve(performance.now() - tStart); } };
            img.src = PING_IMAGE + '?_=' + Math.random();
            setTimeout(()=>{ if(!done) resolve(performance.now() - tStart); }, 1500);
          });
          sum += dur;
        }catch(_){
          const t1 = performance.now(); sum += (t1 - t0);
        }
      }
      await new Promise(r=>setTimeout(r,120));
    }
    const avg = sum/tries;
    return Math.round(avg);
  }

  // download: fetch a file but only read first chunk to measure throughput
  async function measureDownload(){
    status.textContent = 'Measuring download...';
    const url = DOWNLOAD_URL; // use a known CORS-friendly test file
    // First, try to fetch the full HTML/text with CORS enabled so we can measure exact bytes.
    try{
  const t0 = performance.now();
  const resp = await fetch(url, {cache:'no-store', mode:'cors'});
      const t1 = performance.now();
      if(!resp.ok) throw new Error('Non-OK response: ' + resp.status);
      // try to read entire body as text (suitable for HTML pages)
      const text = await resp.text();
      const t2 = performance.now();
      // calculate bytes using TextEncoder
      const enc = new TextEncoder();
      const bytes = enc.encode(text).length;
      const durationSec = (t2 - t0) / 1000; // include full fetch+read time
      const bits = bytes * 8;
      const bps = bits / Math.max(0.0001, durationSec);
      setProgress(80);
      return bps;
    }catch(fetchErr){
      // fetch failed — unexpected for our CORS-friendly endpoint. Try a timing-only fetch with mode:'no-cors' to at least measure time.
      try{
        const t0 = performance.now();
        // no-cors fetch will succeed but give opaque response; still measures timing
        await fetch(url, {cache:'no-store', mode:'no-cors'});
        const t1 = performance.now();
        // return NaN to indicate we couldn't get bytes, but provide timing info via status
        setProgress(50);
        return NaN;
      }catch(_){
        // If no-cors also fails, fall back to iframe timing
      }
      // Fall back to iframe timing which will avoid fetch CORS errors.
      status.textContent = 'Download fetch blocked or failed; using timing fallback...';
      try{
        // create hidden iframe and measure load time
        const iframe = document.createElement('iframe');
        iframe.style.width = '1px'; iframe.style.height = '1px'; iframe.style.position = 'fixed'; iframe.style.left = '-9999px';
        const src = url + (url.indexOf('?')===-1 ? '?_=' : '&_=') + Math.random();
        const tStart = performance.now();
        document.body.appendChild(iframe);
        await new Promise((resolve)=>{
          let done = false;
          const to = setTimeout(()=>{ if(!done){ done = true; resolve(); } }, 4500);
          iframe.onload = ()=>{ if(!done){ done = true; clearTimeout(to); resolve(); } };
          iframe.onerror = ()=>{ if(!done){ done = true; clearTimeout(to); resolve(); } };
          iframe.src = src;
        });
        const tEnd = performance.now();
        // try to find a resource timing entry for the iframe document
        let bps = NaN;
        try{
          const entries = performance.getEntriesByType('resource');
          // find entry whose name starts with the url (resource timing may or may not provide transferSize)
          const entry = entries.slice().reverse().find(e => e.name && e.name.indexOf(url) === 0);
          if(entry && entry.transferSize && entry.transferSize > 0){
            const bytes = entry.transferSize;
            const durationSec = Math.max(0.001, (entry.responseEnd - entry.startTime)/1000);
            bps = (bytes * 8) / durationSec;
          } else {
            // no reliable size — at least compute approximate speed using time and a placeholder size (unknown)
            bps = NaN;
          }
        }catch(e){ bps = NaN; }
        // cleanup iframe
        try{ document.body.removeChild(iframe); }catch(_){}
        // If we couldn't determine bps, return NaN to indicate unknown but not throw
        return bps;
      }catch(err){
        // final fallback: propagate fetch error message but don't throw raw network error
        throw new Error('Download failed: ' + (fetchErr && fetchErr.message ? fetchErr.message : fetchErr));
      }
    }
  }

  // upload: POST a blob of random data to httpbin and measure time
  async function measureUpload(){
    status.textContent = 'Measuring upload...';
    const size = 1*1024*1024; // 1MB
    const chunk = new Uint8Array(size);
    crypto.getRandomValues(chunk);
    const blob = new Blob([chunk]);
    const start = performance.now();
    // use fetch
    const resp = await fetch(UPLOAD_URL, {method:'POST', body:blob});
    const end = performance.now();
    if(!resp.ok) throw new Error('Upload failed');
    const durationSec = (end-start)/1000;
    const bits = size * 8;
    const bps = bits / durationSec;
    // update progress to near complete
    setProgress(95);
    return bps;
  }

  function showResults(dl, ul, ping){
    resultsEl.style.display = 'grid';
    if(!isFinite(dl)){
      dlEl.textContent = 'timing-only';
      dlUnit.textContent = '';
    }else{
      dlEl.textContent = formatSpeed(dl, unitSel.value);
      dlUnit.textContent = unitSel.value === 'kbps' ? 'kbps' : unitSel.value === 'mbps' ? 'Mbps' : 'Gbps';
    }
    if(!isFinite(ul)){
      ulEl.textContent = 'timing-only';
      ulUnit.textContent = '';
    }else{
      ulEl.textContent = formatSpeed(ul, unitSel.value);
      ulUnit.textContent = unitSel.value === 'kbps' ? 'kbps' : unitSel.value === 'mbps' ? 'Mbps' : 'Gbps';
    }
    pingEl.textContent = ping + '';
  }

  function setControlsDisabled(disabled){
    runBtn.disabled = disabled;
    unitSel.disabled = disabled;
    // other UI elements removed; only keep unit and run button
  }

  runBtn.addEventListener('click', async ()=>{
    setControlsDisabled(true);
    resultsEl.style.display = 'none';
    setProgress(2);
    try{
      // ping
      const ping = await measurePing();
      setProgress(20);
      // download
      const dl = await measureDownload();
      setProgress(70);
      // upload
      const ul = await measureUpload();
      setProgress(100);
      status.textContent = 'Done';
      showResults(dl, ul, ping);
    }catch(err){
      status.textContent = 'Error: ' + (err && err.message ? err.message : err);
    }finally{
      setControlsDisabled(false);
    }
  });

})();
</script>
</body>
</html>
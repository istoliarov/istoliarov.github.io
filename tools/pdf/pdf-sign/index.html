<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>PDF Toolbox â€” Sign PDF</title>
  <meta name="description" content="Add digital signature to PDF files â€” client-side. Support for drag and drop.">
  <meta name="keywords" content="sign pdf, pdf signature, add signature to pdf, digital signature">
  <link rel="canonical" href="/tools/pdf/pdf-sign/">
  <meta name="robots" content="index,follow">
  <link rel="stylesheet" href="../styles.css">
  <style>
    /* Tool-specific overrides (do not override .card) */
    .signature-input-group{margin-top:16px;border-top:1px solid #eee;padding-top:16px}
    .signature-input-group label{margin-bottom:8px}
    .signature-text-input{width:100%;padding:10px;border:1px solid #ddd;border-radius:6px;font-size:.95rem;font-family:Arial,sans-serif}
    .signature-text-input:focus{outline:none;border-color:var(--accent)}
    .signature-canvas{border:1px solid #ddd;border-radius:6px;cursor:crosshair;background:#fff;width:100%;height:150px;margin-top:8px}
    .signature-controls{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap}
    .signature-controls button{font-size:.9rem;padding:8px 12px}
    .signature-mode-selector{display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap}
    .signature-mode-selector label{margin:0;display:flex;align-items:center;gap:6px;font-weight:400}
    .signature-mode-selector input[type=radio]{margin:0}
  </style>
  <meta property="og:title" content="PDF Toolbox â€” Sign PDF">
  <meta property="og:description" content="Add digital signature to PDF files directly in your browser. Support for drag and drop.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="/tools/pdf/pdf-sign/">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="PDF Toolbox â€” Sign PDF">
  <meta name="twitter:description" content="Add digital signature to PDF files directly in your browser.">
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebPage",
    "name": "PDF Toolbox â€” Sign PDF",
    "description": "Add digital signature to PDF files client-side with drag and drop support.",
    "url": "/tools/pdf/pdf-sign/"
  }
  </script>
  <script src="../menu-config.js"></script>
  <script src="../navbar.js"></script>
  <script src="../dist/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="../dist/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
  <div id="navbar-container"></div>

  <div class="wrap">
    <h1>Sign PDF</h1>
    <div class="hint-header">Add your digital signature to PDF files â€” entirely in your browser</div>

    <div class="card">
      <label>Upload PDF File</label>
      <div id="dropzone" class="dropzone">
        <div class="dropzone-icon">ðŸ“„</div>
        <div>Drop PDF file here or <label for="fileInput" class="file-input-label">Browse Files</label></div>
        <div class="dropzone-text">Supports PDF documents</div>
        <input id="fileInput" type="file" accept="application/pdf">
      </div>

      <div id="fileInfo" class="file-info" style="display:none"></div>

      <div class="signature-input-group" id="signatureGroup" style="display:none">
        <div class="signature-mode-selector">
          <label><input type="radio" name="signMode" value="text" checked> Text Signature</label>
          <label><input type="radio" name="signMode" value="draw"> Draw Signature</label>
        </div>

        <div id="textSignaturePanel">
          <label for="signatureText">Signature Text</label>
          <input id="signatureText" type="text" class="signature-text-input" placeholder="Enter your name or signature text">
          <div class="hint">Leave blank to use default signature format</div>
        </div>

        <div id="drawSignaturePanel" style="display:none">
          <label>Draw Your Signature</label>
          <canvas id="signatureCanvas" class="signature-canvas"></canvas>
          <div class="signature-controls">
            <button type="button" id="clearSignatureBtn">Clear</button>
            <button type="button" id="undoSignatureBtn">Undo</button>
          </div>
        </div>

        <div id="signPreviewContainer" class="sign-preview-container" style="display:none">
          <div class="sign-preview-label">Preview & Position Signature</div>
          <div class="sign-preview-canvas-wrap">
            <canvas id="pdfPreviewCanvas" class="sign-preview-canvas"></canvas>
            <canvas id="signatureOverlayCanvas" class="sign-preview-overlay"></canvas>
          </div>
          <div class="sign-preview-hint">Drag the signature to position it on the page.<br>Touch and hold to move on mobile.</div>
        </div>

        <div class="position-controls">
          <div>
            <label for="signaturePage">Page:</label>
            <select id="signaturePage">
              <option value="1">First Page</option>
              <option value="last">Last Page</option>
            </select>
          </div>
          <div>
            <label for="signaturePosition">Position:</label>
            <select id="signaturePosition">
              <option value="bottom-right">Bottom Right</option>
              <option value="bottom-left">Bottom Left</option>
              <option value="top-right">Top Right</option>
              <option value="top-left">Top Left</option>
              <option value="center">Center</option>
              <option value="custom">Custom (dragged)</option>
            </select>
          </div>
        </div>
      </div>

      <div class="controls">
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="signBtn" disabled>Sign PDF</button>
          <button id="clearBtn" class="secondary" style="display:none">Clear</button>
        </div>
      </div>

      <div id="output" class="hint"></div>
      <div id="progress" style="margin-top:8px"></div>
    </div>
  </div>

  <script>
  (function() {
    const { jsPDF } = window.jspdf;
    const pdfjsLib = window['pdfjs-dist/build/pdf'];
    pdfjsLib.GlobalWorkerOptions.workerSrc = '../dist/pdf.js/2.16.105/pdf.worker.min.js';

    let pdfDoc = null;
    let fileData = null;
    let fileName = '';
    let signatureCanvas = null;
    let signatureCtx = null;
    let isDrawing = false;
    let strokes = [];

    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const fileInfo = document.getElementById('fileInfo');
    const signatureGroup = document.getElementById('signatureGroup');
    const signBtn = document.getElementById('signBtn');
    const clearBtn = document.getElementById('clearBtn');
    const output = document.getElementById('output');
    const progress = document.getElementById('progress');
    const signatureModeRadios = document.querySelectorAll('input[name="signMode"]');
    const textPanel = document.getElementById('textSignaturePanel');
    const drawPanel = document.getElementById('drawSignaturePanel');
    const signatureText = document.getElementById('signatureText');
    const clearSignatureBtn = document.getElementById('clearSignatureBtn');
    const undoSignatureBtn = document.getElementById('undoSignatureBtn');

    // Populate tools dropdown
    populateToolsDropdown();

    // Initialize signature canvas
    function initSignatureCanvas() {
      signatureCanvas = document.getElementById('signatureCanvas');
      signatureCtx = signatureCanvas.getContext('2d');
      // Set canvas resolution (account for devicePixelRatio)
      const rect = signatureCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      signatureCanvas.width = Math.round(rect.width * dpr);
      signatureCanvas.height = Math.round(rect.height * dpr);
      signatureCanvas.style.width = rect.width + 'px';
      signatureCanvas.style.height = rect.height + 'px';
      signatureCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      signatureCanvas.addEventListener('mousedown', startDrawing);
      signatureCanvas.addEventListener('mousemove', draw);
      signatureCanvas.addEventListener('mouseup', stopDrawing);
      signatureCanvas.addEventListener('mouseout', stopDrawing);
      // Touch support
      signatureCanvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousedown', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        signatureCanvas.dispatchEvent(mouseEvent);
      });
      signatureCanvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const touch = e.touches[0];
        const mouseEvent = new MouseEvent('mousemove', {
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        signatureCanvas.dispatchEvent(mouseEvent);
      });
      signatureCanvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const mouseEvent = new MouseEvent('mouseup', {});
        signatureCanvas.dispatchEvent(mouseEvent);
      });
    }

    function startDrawing(e) {
      if (document.querySelector('input[name="signMode"]:checked').value !== 'draw') return;
      isDrawing = true;
      const rect = signatureCanvas.getBoundingClientRect();
      const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
      const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
      signatureCtx.beginPath();
      signatureCtx.moveTo(x, y);
      strokes.push({points: [{x, y}], color: '#000', width: 2});
    }

    function draw(e) {
      if (!isDrawing || document.querySelector('input[name="signMode"]:checked').value !== 'draw') return;
      const rect = signatureCanvas.getBoundingClientRect();
      const x = (e.clientX || (e.touches && e.touches[0].clientX)) - rect.left;
      const y = (e.clientY || (e.touches && e.touches[0].clientY)) - rect.top;
      signatureCtx.lineWidth = 2;
      signatureCtx.lineCap = 'round';
      signatureCtx.lineJoin = 'round';
      signatureCtx.strokeStyle = '#000';
      signatureCtx.lineTo(x, y);
      signatureCtx.stroke();
      if (strokes.length > 0) {
        strokes[strokes.length - 1].points.push({x, y});
      }
    }

    document.getElementById('signaturePage').addEventListener('change', () => {
      renderSignPreview();
    });
    document.getElementById('signaturePosition').addEventListener('change', () => {
      renderSignPreview();
    });

    // --- Sign Preview Logic ---
    let overlayDragging = false;
    let overlayOffsetX = 0;
    let overlayOffsetY = 0;
    let overlayX = 0;
    let overlayY = 0;
    let overlayWidth = 120;
    let overlayHeight = 40;
    let overlayScale = 1;
    let overlayPageWidth = 0;
    let overlayPageHeight = 0;
    let overlayLastTouchId = null;

    async function renderSignPreview() {
      const previewContainer = document.getElementById('signPreviewContainer');
      const pdfCanvas = document.getElementById('pdfPreviewCanvas');
      const overlayCanvas = document.getElementById('signatureOverlayCanvas');
      if (!pdfDoc) {
        previewContainer.style.display = 'none';
        return;
      }
      previewContainer.style.display = 'block';
      const pageSelect = document.getElementById('signaturePage');
      let pageNum = pageSelect.value === 'last' ? pdfDoc.numPages : parseInt(pageSelect.value);
      const page = await pdfDoc.getPage(pageNum);
      const scale = 1.2;
      const viewport = page.getViewport({ scale });
      const dpr = window.devicePixelRatio || 1;
      // Set canvas internal resolution for crisp rendering
      pdfCanvas.width = Math.round(viewport.width * dpr);
      pdfCanvas.height = Math.round(viewport.height * dpr);
      pdfCanvas.style.width = viewport.width + 'px';
      pdfCanvas.style.height = viewport.height + 'px';
      overlayCanvas.width = Math.round(viewport.width * dpr);
      overlayCanvas.height = Math.round(viewport.height * dpr);
      overlayCanvas.style.width = viewport.width + 'px';
      overlayCanvas.style.height = viewport.height + 'px';
      overlayPageWidth = viewport.width;
      overlayPageHeight = viewport.height;
        overlayScale = scale;
        // Render PDF page with DPR-aware context
        const pdfCtx = pdfCanvas.getContext('2d');
        pdfCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        await page.render({ canvasContext: pdfCtx, viewport }).promise;
        // Determine signature image/text
        let signMode = document.querySelector('input[name="signMode"]:checked').value;
        let sigImg = null;
        if (signMode === 'draw' && strokes.length > 0 && signatureCanvas) {
          sigImg = signatureCanvas.toDataURL('image/png');
        }
        // Default overlay size
        overlayWidth = Math.round(viewport.width * 0.25);
        overlayHeight = Math.round(viewport.height * 0.08);
        // Initial position based on selector
        let pos = document.getElementById('signaturePosition').value;
        if (pos !== 'custom') {
          const positions = {
            'bottom-right': { x: viewport.width - overlayWidth - 16, y: viewport.height - overlayHeight - 16 },
            'bottom-left': { x: 16, y: viewport.height - overlayHeight - 16 },
            'top-right': { x: viewport.width - overlayWidth - 16, y: 16 },
            'top-left': { x: 16, y: 16 },
            'center': { x: (viewport.width - overlayWidth) / 2, y: (viewport.height - overlayHeight) / 2 }
          };
          overlayX = positions[pos].x;
          overlayY = positions[pos].y;
        }
        // Draw overlay
        drawSignatureOverlay(sigImg);
        attachOverlayListeners();
      }

      function drawSignatureOverlay(sigImg) {
        const overlayCanvas = document.getElementById('signatureOverlayCanvas');
        const ctx = overlayCanvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        // Clear using device pixels, then set transform so drawing coords are in CSS pixels
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        let signMode = document.querySelector('input[name="signMode"]:checked').value;
        if (signMode === 'draw' && sigImg) {
          let img = new window.Image();
          img.onload = function() {
            ctx.globalAlpha = 0.95;
            ctx.drawImage(img, overlayX, overlayY, overlayWidth, overlayHeight);
            ctx.globalAlpha = 1;
            drawOverlayBorder(ctx);
          };
          img.src = sigImg;
        } else if (signMode === 'text') {
          let text = signatureText.value.trim() || 'Signature';
          ctx.save();
          ctx.globalAlpha = 0.95;
          ctx.fillStyle = '#222';
          ctx.font = `bold ${Math.round(overlayHeight * 0.7)}px Arial`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = 'center';
          ctx.fillText(text, overlayX + overlayWidth / 2, overlayY + overlayHeight / 2, overlayWidth - 8);
          ctx.restore();
          drawOverlayBorder(ctx);
        }
      }

      function drawOverlayBorder(ctx) {
        ctx.save();
        ctx.strokeStyle = 'var(--accent)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.strokeRect(overlayX, overlayY, overlayWidth, overlayHeight);
        ctx.restore();
      }

      function overlayPointerDown(e) {
        let x, y;
        if (e.touches) {
          const touch = e.touches[0];
          x = touch.clientX;
          y = touch.clientY;
          overlayLastTouchId = touch.identifier;
        } else {
          x = e.clientX;
          y = e.clientY;
        }
        const rect = e.target.getBoundingClientRect();
        const px = x - rect.left;
        const py = y - rect.top;
        if (px >= overlayX && px <= overlayX + overlayWidth && py >= overlayY && py <= overlayY + overlayHeight) {
          overlayDragging = true;
          overlayOffsetX = px - overlayX;
          overlayOffsetY = py - overlayY;
          e.preventDefault();
        }
      }
      function overlayPointerMove(e) {
        if (!overlayDragging) return;
        let x, y;
        if (e.touches) {
          const touch = Array.from(e.touches).find(t => t.identifier === overlayLastTouchId) || e.touches[0];
          x = touch.clientX;
          y = touch.clientY;
        } else {
          x = e.clientX;
          y = e.clientY;
        }
        const rect = e.target.getBoundingClientRect();
        let px = x - rect.left;
        let py = y - rect.top;
        overlayX = Math.max(0, Math.min(px - overlayOffsetX, overlayPageWidth - overlayWidth));
        overlayY = Math.max(0, Math.min(py - overlayOffsetY, overlayPageHeight - overlayHeight));
        drawSignatureOverlay(
          document.querySelector('input[name="signMode"]:checked').value === 'draw' && signatureCanvas && strokes.length > 0
            ? signatureCanvas.toDataURL('image/png')
            : null
        );
        document.getElementById('signaturePosition').value = 'custom';
      }
      function overlayPointerUp(e) {
        overlayDragging = false;
        overlayLastTouchId = null;
      }
      function overlayPointerLeave(e) {
        overlayDragging = false;
        overlayLastTouchId = null;
      }
      function attachOverlayListeners() {
        const overlayCanvas = document.getElementById('signatureOverlayCanvas');
        overlayCanvas.onmousedown = overlayPointerDown;
        overlayCanvas.onmousemove = overlayPointerMove;
        overlayCanvas.onmouseup = overlayPointerUp;
        overlayCanvas.onmouseleave = overlayPointerLeave;
        overlayCanvas.ontouchstart = overlayPointerDown;
        overlayCanvas.ontouchmove = overlayPointerMove;
        overlayCanvas.ontouchend = overlayPointerUp;
        overlayCanvas.ontouchcancel = overlayPointerLeave;
        }

    function stopDrawing() {
      isDrawing = false;
    }

    clearSignatureBtn.addEventListener('click', () => {
      signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      strokes = [];
      signatureText.value = '';
      renderSignPreview();
    });

    undoSignatureBtn.addEventListener('click', () => {
      if (strokes.length > 0) {
        strokes.pop();
        redrawCanvas();
      }
    });

    function redrawCanvas() {
      signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      strokes.forEach(stroke => {
        signatureCtx.strokeStyle = stroke.color;
        signatureCtx.lineWidth = stroke.width;
        signatureCtx.lineCap = 'round';
        signatureCtx.lineJoin = 'round';
        if (stroke.points.length > 0) {
          signatureCtx.beginPath();
          signatureCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
          for (let i = 1; i < stroke.points.length; i++) {
            signatureCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
          }
          signatureCtx.stroke();
        }
      });
      renderSignPreview();
    }

    // Signature mode toggle
    signatureModeRadios.forEach(radio => {
      radio.addEventListener('change', (e) => {
        if (e.target.value === 'text') {
          textPanel.style.display = 'block';
          drawPanel.style.display = 'none';
          signatureText.focus();
        } else {
          textPanel.style.display = 'none';
          drawPanel.style.display = 'block';
          if (!signatureCanvas) initSignatureCanvas();
        }
      });
    });

    // Utility functions
    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 10000);
    }

    function setProgress(pct, text) {
      progress.innerHTML = `<div class="progress"><i style="width:${pct}%"></i></div>` + 
        (text ? `<div class="hint">${text}</div>` : '');
    }

    function clearProgress() {
      progress.innerHTML = '';
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }

    // Load PDF file
    async function loadPdfFile(file) {
      fileData = file;
      fileName = file.name.replace(/\.pdf$/i, '') || 'document';
      
      try {
        const arrayBuf = await file.arrayBuffer();
        pdfDoc = await pdfjsLib.getDocument({ data: arrayBuf }).promise;
        
        // Update page selector
        const pageSelect = document.getElementById('signaturePage');
        pageSelect.innerHTML = '<option value="1">Page 1 (First)</option>';
        for (let i = 2; i <= pdfDoc.numPages; i++) {
          pageSelect.appendChild(new Option(`Page ${i}`, i.toString()));
        }
        if (pdfDoc.numPages > 1) {
          pageSelect.appendChild(new Option(`Page ${pdfDoc.numPages} (Last)`, 'last'));
        }
        
        // Show file info
        fileInfo.innerHTML = `
          <span>ðŸ“„ ${file.name}</span>
          <span>ðŸ“Š ${formatFileSize(file.size)}</span>
          <span>ðŸ“‘ ${pdfDoc.numPages} page${pdfDoc.numPages !== 1 ? 's' : ''}</span>
        `;
        fileInfo.style.display = 'flex';
        signatureGroup.style.display = 'block';
        
        signBtn.disabled = false;
        clearBtn.style.display = 'inline-block';
        output.innerHTML = '';
      } catch (err) {
        output.innerHTML = `<div class="error">Error loading PDF: ${err.message}</div>`;
      }
    }

    // Setup dropzone
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      dropzone.addEventListener(eventName, () => {
        dropzone.classList.add('dragover');
      }, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, () => {
        dropzone.classList.remove('dragover');
      }, false);
    });

    dropzone.addEventListener('drop', (e) => {
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const file = files[0];
        if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) {
          loadPdfFile(file);
        } else {
          output.innerHTML = '<div class="error">Please drop a valid PDF file.</div>';
        }
      }
    }, false);

    fileInput.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        loadPdfFile(e.target.files[0]);
        fileInput.value = '';
      }
    });

    // Click on dropzone to trigger file input
    dropzone.addEventListener('click', () => {
      fileInput.click();
    });

    // Sign PDF
    signBtn.addEventListener('click', async () => {
      if (!pdfDoc) {
        output.innerHTML = '<div class="error">Please select or drop a PDF file.</div>';
        return;
      }

      const signMode = document.querySelector('input[name="signMode"]:checked').value;
      const signText = signatureText.value.trim();
      
      if (signMode === 'text' && !signText) {
        output.innerHTML = '<div class="error">Please enter signature text.</div>';
        return;
      }

      if (signMode === 'draw' && strokes.length === 0) {
        output.innerHTML = '<div class="error">Please draw your signature.</div>';
        return;
      }

      output.innerHTML = '';
      setProgress(10, 'Loading PDF...');

      try {
        const signaturePage = document.getElementById('signaturePage').value;
        const signaturePos = document.getElementById('signaturePosition').value;
        const pageNum = signaturePage === 'last' ? pdfDoc.numPages : parseInt(signaturePage);

        const pdf = new jsPDF({
          unit: 'mm',
          format: 'a4'
        });

        // Copy all pages
        for (let p = 1; p <= pdfDoc.numPages; p++) {
          setProgress(
            Math.round((p / pdfDoc.numPages) * 50),
            `Processing page ${p} of ${pdfDoc.numPages}...`
          );

          const page = await pdfDoc.getPage(p);
          const viewport = page.getViewport({ scale: 1.5 });
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = viewport.width;
          canvas.height = viewport.height;

          await page.render({ canvasContext: ctx, viewport: viewport }).promise;
          
          if (p > 1) {
            pdf.addPage();
          }

          const imgData = canvas.toDataURL('image/png');
          const pageWidth = pdf.internal.pageSize.getWidth();
          const pageHeight = pdf.internal.pageSize.getHeight();
          pdf.addImage(imgData, 'PNG', 0, 0, pageWidth, pageHeight);
        }

        // Add signature to specified page
        setProgress(75, 'Adding signature...');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        const padding = 5;
        let sigWidth = 40;
        let sigHeight = 15;

        let x, y;
        if (signaturePos === 'custom') {
          // Map overlay coordinates (in preview pixels) to PDF units
          const previewCanvas = document.getElementById('pdfPreviewCanvas');
          const previewW = previewCanvas.width / (window.devicePixelRatio || 1);
          const previewH = previewCanvas.height / (window.devicePixelRatio || 1);
          const scaleX = pageWidth / previewW;
          const scaleY = pageHeight / previewH;
          x = overlayX * scaleX;
          y = overlayY * scaleY;
          sigWidth = overlayWidth * scaleX;
          sigHeight = overlayHeight * scaleY;
        } else {
          const positions = {
            'bottom-right': { x: pageWidth - sigWidth - padding, y: pageHeight - sigHeight - padding },
            'bottom-left': { x: padding, y: pageHeight - sigHeight - padding },
            'top-right': { x: pageWidth - sigWidth - padding, y: padding },
            'top-left': { x: padding, y: padding },
            'center': { x: (pageWidth - sigWidth) / 2, y: (pageHeight - sigHeight) / 2 }
          };
          const pos = positions[signaturePos];
          x = pos.x;
          y = pos.y;
        }

        // Set active page for signature
        if (pageNum > 1) {
          pdf.setPage(pageNum);
        }

        if (signMode === 'text') {
          pdf.setTextColor(0, 0, 0);
          pdf.setFontSize(10);
          pdf.text(signText, x, y + 8, { maxWidth: sigWidth });
        } else {
          const sigImage = signatureCanvas.toDataURL('image/png');
          pdf.addImage(sigImage, 'PNG', x, y, sigWidth, sigHeight);
        }

        setProgress(90, 'Generating PDF...');
        const blob = pdf.output('blob');
        const filename = `${fileName}-signed-${new Date().getTime()}.pdf`;
        downloadBlob(blob, filename);

        // Store blob for re-download
        const downloadLink = document.createElement('a');
        downloadLink.href = URL.createObjectURL(blob);
        downloadLink.download = filename;
        downloadLink.style.cssText = 'color:var(--accent);text-decoration:underline;cursor:pointer';
        downloadLink.textContent = 'Download again';
        downloadLink.onclick = (e) => {
          e.preventDefault();
          downloadLink.click();
        };

        const successDiv = document.createElement('div');
        successDiv.className = 'success';
        successDiv.innerHTML = `âœ“ Successfully signed PDF. `;
        successDiv.appendChild(downloadLink);
        output.innerHTML = '';
        output.appendChild(successDiv);
        
        clearProgress();
      } catch (err) {
        output.innerHTML = `<div class="error">Error: ${err.message}</div>`;
        clearProgress();
        console.error(err);
      }
    });

    // Clear file
    clearBtn.addEventListener('click', () => {
      pdfDoc = null;
      fileData = null;
      fileName = '';
      fileInfo.style.display = 'none';
      signatureGroup.style.display = 'none';
      signBtn.disabled = true;
      clearBtn.style.display = 'none';
      output.innerHTML = '';
      clearProgress();
      fileInput.value = '';
      signatureText.value = '';
      strokes = [];
      if (signatureCanvas) {
        signatureCtx.clearRect(0, 0, signatureCanvas.width, signatureCanvas.height);
      }
    });
  })();
  </script>

  <div id="footer-container"></div>
  <script src="../footer.js"></script>
</body>
</html>
